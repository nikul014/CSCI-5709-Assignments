# Assignment 3

* *Date Created*: 28 July, 2024
* *Last Modification Date*: 30 July, 2024
* *Frontend application URL*: <https://thecalmessence.netlify.app/>
* *Backend application URL*: <https://csci-5709-group8.onrender.com>
* *Git URL*: <https://git.cs.dal.ca/parkar/CSCI-5709-Group8/-/tree/main/calmessence?ref_type=heads>

## Authors

* Nikulkumar Kukadiya (nk865270@dal.ca)

## Deployment

The project code will be pushed to the main branch of the GitHub repository [GitHub repository](https://github.com/rameez-parkar/CSCI-5709-Group8), which is mirrored in [GitLab repository](https://git.cs.dal.ca/parkar/CSCI-5709-Group8/-/tree/main/calmessence?ref_type=heads) and it will be deployed on [Netlify](https://thecalmessence.netlify.app/), and the live version can be accessed through the Netlify link (Netlify Link). Backend has been deployed to the Render [Render](https://csci-5709-group8.onrender.com)

To deploy:
  1. Push your code to the main branch of the GitHub repository.
  2. Import the term project's calmessence folder on Netlify from GitHub.
  3. Set up build settings to deploy the application.
  4. The application will be live on the specified link.
  5. Import the term project's backend folder on Render from Github.
  6. Set up build settings to deploy the application.
  7. The application will be live on the specified link.

## Folder Structure For Live session module

Github repo: CSCI-5709-Group8
- backend
    - src
      - controllers
        - tokenController.js
        - sessionController.js
      - routes
        - sessionRoutes.js
        - tokenRoutes.js
    - app.js

- calmessence
    - components
       - LiveSession.jsx
       - LiveSessionItemCard.jsx
       - Loader.jsx
       - PrivateRoute.jsx
       - VideoCall.jsx
       - UserProfile.jsx
    - App.jsx
    - AuthContext.js


### Backend

The `backend` folder contains the server-side code, organized as follows:

- src: Source files for the backend.

  - controllers: Contains the controller files that handle the business logic for different entities.

    - tokenController.js: Controller for creation and handling the agora video sdk token generation.

    - sessionController.js: Controller for creation, editing and fetching the sessions details generated by the experts.

  - routes: Contains the route files that define the API endpoints.

    - sesssionRoutes.js: Routes for session-related API endpoints.
    - tokenRoutes.js: Routes for agora token-related API endpoints.
  - app.js: The main entry point for the backend application.

### Calmessence

The `calmessence` folder contains the frontend code, organized as follows:

- components: Contains the React components used in the frontend application.

  - LiveSession.jsx: Component for displaying a live sessions list on user and expert side.

  - LiveSessionItemCard.jsx: Component for showing session details.

  - Loader.jsx: Component for showing the loader

  - PrivateRoute.jsx: Component for redirecting the user to signup or login screen 

  - VideoCall.jsx: Component for showing the live streaming of the user and expert session.

  - UserProfile.jsx: Component to show the login or user profile details when logged in or logout.

- App.jsx: The main entry point for the frontend application.

- AuthContext.jsx: The main controller which will store and manage the logged in user information.



## Built With

* [React](https://legacy.reactjs.org/docs/getting-started.html/) - The web framework used [1]
* [npm](https://docs.npmjs.com//) - Dependency Management [2]
* [Tailwnd css](https://tailwindcss.com/docs/installation)- Used for application CSS [3]

## Sources Used

### sessionController.js

The sessionController.js file is responsible for managing the session creation, edition and listing apis. Below is the code for the same:

```
const createSession = async (req, res) => {
    const { title, description, session_date, session_time, duration, expert_id, expert_email } = req.body;

    if (!title || !session_date || !session_time || duration === undefined || !expert_id || !expert_email) {
        return res.status(400).json({ error: 'Missing required fields' });
    }

    try {
        const connection = getConnection();
        const [insertResult] = await connection.execute(
            `INSERT INTO session (title, description, session_date, session_time, duration, expert_id, expert_email)
             VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [title, description, session_date, session_time, duration, expert_id, expert_email]
        );

        const sessionId = insertResult.insertId;
        await connection.execute(`UPDATE session
                                  SET agora_channel_id = ?
                                  WHERE session_id = ?`, [sessionId, sessionId]);

        res.status(201).json({
            message: 'Session created successfully',
            sessionId: sessionId,
            agoraChannelId: sessionId
        });
    } catch (error) {
        console.error('Error creating session:', error);
        res.status(500).json({ error: 'Error creating session' });
    }
};

const editSession = async (req, res) => {
    const { session_id, title, description, session_date, session_time, duration, actual_start_time, status } = req.body;

    if (!session_id) {
        return res.status(400).json({ error: 'Missing session_id' });
    }

    try {
        const connection = getConnection();
        const fieldsToUpdate = {};
        if (title !== undefined) fieldsToUpdate.title = title;
        if (description !== undefined) fieldsToUpdate.description = description;
        if (session_date !== undefined) fieldsToUpdate.session_date = session_date;
        if (session_time !== undefined) fieldsToUpdate.session_time = session_time;
        if (duration !== undefined) fieldsToUpdate.duration = duration;
        if (actual_start_time !== undefined) fieldsToUpdate.actual_start_time = actual_start_time;
        if (status !== undefined) fieldsToUpdate.status = status;

        if (Object.keys(fieldsToUpdate).length === 0) {
            return res.status(400).json({ error: 'No fields to update' });
        }

        const setClause = Object.keys(fieldsToUpdate).map(field => `${field} = ?`).join(', ');
        const values = Object.values(fieldsToUpdate);
        values.push(session_id);

        const [updateResult] = await connection.execute(`UPDATE session
                                                         SET ${setClause}
                                                         WHERE session_id = ?`, values);

        res.status(200).json({
            message: 'Session updated successfully',
            affectedRows: updateResult.affectedRows
        });
    } catch (error) {
        console.error('Error updating session:', error);
        res.status(500).json({ error: 'Error updating session' });
    }
};


const getSessionList = async (req, res) => {
    const searchTerm = req.query.searchTerm || '';
    const page = parseInt(req.query.page, 10) || 1;
    const pageSize = parseInt(req.query.pageSize, 10) || 10;

    // Calculate offset for pagination
    const offset = (page - 1) * pageSize;

    try {
        const connection = getConnection();
        // Fetch the sessions with pagination and search

        const sqlQuery = `
            SELECT *
            FROM session
            WHERE title LIKE '%${searchTerm}%' AND status != 'completed'
            ORDER BY session_date DESC
                LIMIT ${pageSize}
            OFFSET ${offset}
        `;
        console.log('SQL Query:', sqlQuery);
        const [results] = await connection.execute(sqlQuery);
        // Fetch total count for pagination
        const [[{count}]] = await connection.execute(`
            SELECT COUNT(*) AS count
            FROM session
            WHERE title LIKE ?  AND status != 'completed'
        `, [`%${searchTerm}%`]);

        res.json({
            data: results,
            pagination: {
                page: page,
                pageSize: pageSize,
                totalItems: count,
                totalPages: Math.ceil(count / pageSize)
            }
        });
    } catch (error) {
        console.error('Error fetching session list:', error);
        res.status(500).json({error: 'Error fetching session list'});
    }
};


router.post('/create', createSession);
router.post('/edit', editSession);
router.get('/list', getSessionList);

```


This file uses SQL queries to interact with the database and create the 3 api end points create, edit and list the sessions.

### tokenController.js

The tokenController.js file provides the backend functionality for managing the agora token generation for joining the user stream in the application. Below is the code for the same:

```


const APP_ID = 'e947c59bbe8c4287954cb154e63be817';
const APP_CERTIFICATE = '95f38223d7e84dd58236f7bd09b85096';

const generateToken = async (req, res) => {
    const { channelName, uid, role, user_email } = req.body;

    if (!channelName || uid === undefined || !role || !user_email) {
        return res.status(400).json({ error: 'Missing required fields' });
    }

    const currentTimestamp = Math.floor(Date.now() / 1000);
    const expirationTimeInSeconds = 3600;

    let roleEnum;
    if (role === 'publisher') {
        roleEnum = RtcRole.PUBLISHER;
    } else {
        roleEnum = RtcRole.SUBSCRIBER;
    }

    try {
        const connection = getConnection();
        const tokenWithUid = RtcTokenBuilder.RtcTokenBuilder.buildTokenWithUid(
            APP_ID, APP_CERTIFICATE, channelName, uid, roleEnum, expirationTimeInSeconds, currentTimestamp + expirationTimeInSeconds
        );

        const [sessionRows] = await connection.execute('SELECT session_id FROM session WHERE agora_channel_id = ?', [channelName]);

        if (sessionRows.length === 0) {
            return res.status(404).json({ error: 'Session not found' });
        }

        const sessionId = sessionRows[0].session_id;

        const [tokenRows] = await connection.execute(
            'SELECT token_id FROM session_token WHERE session_id = ? AND user_id = ? AND user_email = ?',
            [sessionId, uid, user_email]
        );

        if (tokenRows.length > 0) {
            await connection.execute('UPDATE session_token SET token = ? WHERE token_id = ?', [tokenWithUid, tokenRows[0].token_id]);
        } else {
            await connection.execute(
                'INSERT INTO session_token (session_id, user_id, user_email, token) VALUES (?, ?, ?, ?)',
                [sessionId, uid, user_email, tokenWithUid]
            );
        }

        res.json({
            token: tokenWithUid,
            session_id: sessionId,
            user_id: uid,
            user_email: user_email,
            role: role
        });
    } catch (error) {
        console.error('Error generating token:', error);
        res.status(500).json({ error: 'Error generating token' });
    }
};

module.exports = { generateToken };


router.post('/generate', generateToken);


```
This file utilizes SQL queries to interact with the database and creates the generate token api end point.

All the files from the backend generates the below api end points for my frontend.
- Create Session: POST /create - Creates a new session.
- Edit Session: POST /edit - Updates an existing session.
- Get Session List: GET /list - Retrieves a paginated list of sessions.
- Generate Token: POST /generate - Generates an Agora token for user authentication.

### VideoCall.jsx:
```
import {
    LocalUser,
    RemoteUser,
    useIsConnected,
    useJoin,
    useLocalCameraTrack,
    useLocalMicrophoneTrack,
    usePublish,
    useRemoteUsers,
} from "agora-rtc-react";
import { useEffect, useState } from "react";
import { useLocation, useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import "../styles.css";

export const LiveVideo = () => {
    const { state } = useLocation();
    const { session, loggedInUserId, user_email } = state || {};
    const navigate = useNavigate();

    const appId = 'e947c59bbe8c4287954cb154e63be817';
    const [calling, setCalling] = useState(false);
    const [token, setToken] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const isConnected = useIsConnected();

    // Determine user role
    const isPublisher = loggedInUserId == session.expert_id;
    const role = isPublisher ? 'publisher' : 'subscriber';

    // Fetch the token from the API using session details
    useEffect(() => {
        const fetchToken = async () => {
            try {
                setLoading(true);
                const response = await fetch('https://csci-5709-group8.onrender.com/api/tokens/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        channelName: session.agora_channel_id,
                        uid: loggedInUserId,
                        role: role,
                        expireTime: 3600,
                        user_email: user_email
                    })
                });
                const data = await response.json();
                setToken(data.token);
                setCalling(true);
                setLoading(false);
            } catch (error) {
                console.error('Error fetching token:', error);
                setError('Error fetching token');
                setLoading(false);
            }
        };

        if (session.agora_channel_id && loggedInUserId) {
            fetchToken();
        }
    }, [session.agora_channel_id, loggedInUserId, role, user_email]);

    // Join the channel
    useJoin({ appid: appId, channel: session.agora_channel_id, token: token, uid: loggedInUserId }, calling);

    // Local video and audio tracks
    const { localMicrophoneTrack } = useLocalMicrophoneTrack(isPublisher);
    const { localCameraTrack } = useLocalCameraTrack(isPublisher);

    // Publish tracks when ready
    usePublish([localMicrophoneTrack, localCameraTrack]);

    // Define state variables for mic and camera control
    const [micOn, setMic] = useState(isPublisher);
    const [cameraOn, setCamera] = useState(isPublisher);

    const remoteUsers = useRemoteUsers();

    // Function to handle session completion
    const handleCompleteSession = async () => {
        try {
            const response = await fetch('https://csci-5709-group8.onrender.com/api/sessions/edit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    session_id: session.session_id,
                    status: 'completed',
                }),
            });
            if (!response.ok) {
                throw new Error('Failed to update session status');
            }
            const data = await response.json();
            toast.success('Session updated successfully!');
            console.log('Session updated:', data);
        } catch (error) {
            console.error('Error updating session status:', error);
            toast.error('Failed to update session status.');
        }
    };

    // Handle call control button click
    const handleCallControl = async () => {
        if (calling && isPublisher) {
            await handleCompleteSession();
        }
        setCalling(a => !a);
        navigate('/live-session');
    };

    const expertVideoAvailable = remoteUsers.some(user => user.uid == session.expert_id);

    return (
        <div className="fixed top-0 left-0 bottom-0 right-0 w-full h-full font-poppins text-gray-900 bg-gradient-to-b from-base-200 to-base-200 ">
            {isPublisher && (
                <div className="flex top-0 left-0 bottom-0 right-0 w-full h-full p-4">
                    <div className="w-3/4 h-full rounded-lg p-4 z-10 overflow-auto">
                        <LocalUser
                            audioTrack={localMicrophoneTrack}
                            cameraOn={cameraOn}
                            micOn={micOn}
                            videoTrack={localCameraTrack}
                            cover="https://www.agora.io/en/wp-content/uploads/2022/10/3d-spatial-audio-icon.svg"
                        >
                            <samp className="user-name text-gray-800 font-semibold">You</samp>
                        </LocalUser>
                    </div>
                    <div className="w-1/4 rounded-lg p-4 overflow-auto">
                        {isPublisher && isConnected && (
                            <div className="bg-gray-200 flex flex-col items-center space-y-4 p-4">
                                <div className="bg-white p-8 rounded-lg shadow-md mb-4 w-full max-w-sm text-left">
                                    <h2 className="text-xl font-semibold mb-2">Session Details</h2>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Title:</strong> {session.title}</p>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Description:</strong> {session.description}</p>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Date:</strong> {new Date(session.session_date).toLocaleDateString()}</p>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Time:</strong> {new Date(`1970-01-01T${session.session_time}`).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</p>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Duration:</strong> {session.duration} minutes</p>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Status:</strong> {session.status.charAt(0).toUpperCase() + session.status.slice(1)}</p>
                                    <p className="text-sm text-gray-700 mb-1"><strong>Expert Email:</strong> {session.expert_email}</p>
                                </div>
                                <button
                                    id="mic-control"
                                    className="bg-base-200 text-black p-2 rounded-lg flex items-center"
                                    onClick={() => setMic(a => !a)}
                                >
                                    <i className={`i-microphone ${!micOn ? "off" : ""}`}></i>
                                    <span className="ml-2">{micOn ? "Microphone Enabled" : "Microphone Disabled"}</span>
                                </button>

                                <button
                                    id="camera-control"
                                    className="bg-base-200 text-black p-2 rounded-lg flex items-center"
                                    onClick={() => setCamera(a => !a)}
                                >
                                    <i className={`i-camera ${!cameraOn ? "off" : ""}`}></i>
                                    <span className="ml-2">{cameraOn ? "Camera Enabled" : "Camera Disabled"}</span>
                                </button>
                                <button
                                    id="call-control"
                                    className={`p-2 rounded-lg ${calling ? "bg-red-600 text-white" : "bg-green-600 text-white"}`}
                                    onClick={handleCallControl}
                                >
                                    {calling ? <i className="i-phone-hangup"></i> : <i className="i-mdi-phone"></i>}
                                    <span className="ml-2">{"Close session"}</span>
                                </button>
                            </div>

                        )}
                    </div>
                </div>
            )}

            {isConnected && !expertVideoAvailable && !isPublisher && (
                <div className="fixed inset-0 flex flex-col items-center justify-center bg-white bg-opacity-75">
                    <div className="bg-white p-8 rounded-lg shadow-lg text-center flex flex-col items-center justify-center">
                        <p className="text-xl font-semibold text-gray-900 mb-4">Session has not started yet. Please connect after some time.</p>
                        <div className="bg-white p-4 rounded-lg shadow-md mb-4 w-full max-w-sm text-left">
                            <h2 className="text-xl font-semibold mb-2">Session Details</h2>
                            <p className="text-sm text-gray-700 mb-1"><strong>Title:</strong> {session.title}</p>
                            <p className="text-sm text-gray-700 mb-1"><strong>Description:</strong> {session.description}</p>
                            <p className="text-sm text-gray-700 mb-1"><strong>Date:</strong> {new Date(session.session_date).toLocaleDateString()}</p>
                            <p className="text-sm text-gray-700 mb-1"><strong>Time:</strong> {new Date(`1970-01-01T${session.session_time}`).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</p>
                            <p className="text-sm text-gray-700 mb-1"><strong>Duration:</strong> {session.duration} minutes</p>
                            <p className="text-sm text-gray-700 mb-1"><strong>Status:</strong> {session.status.charAt(0).toUpperCase() + session.status.slice(1)}</p>
                            <p className="text-sm text-gray-700 mb-1"><strong>Expert Email:</strong> {session.expert_email}</p>
                        </div>
                        <button
                            className="bg-black text-white rounded-full py-2 px-4 shadow-md hover:bg-gray-800 transition duration-300"
                            onClick={() => navigate('/live-session')}
                        >
                            Back to Live Session
                        </button>
                    </div>

                </div>
            )}

            <div className="flex flex-col justify-between h-full">
                {loading ? (
                    <div className="flex justify-center items-center h-full">
                        <p className="text-gray-800 font-semibold">Loading...</p>
                    </div>
                ) : error ? (
                    <div className="flex justify-center items-center h-full">
                        <p className="text-red-600 font-semibold">{error}</p>
                    </div>
                ) : (
                    <>
                        <div className="flex-grow">
                            <div className="bg-white shadow-md rounded-lg p-6 mb-6">
                                <div id="user-list" className="gap-4">
                                    {remoteUsers.map((user) => (
                                        user.uid == session.expert_id && (
                                            <div
                                                className="w-[426px] h-[240px] sm:w-[640px] sm:h-[360px] md:w-[854px] md:h-[480px] lg:w-[1280px] lg:h-[720px] bg-white rounded-lg p-4"
                                                key={user.uid}
                                            >
                                                <RemoteUser
                                                    cover="https://www.agora.io/en/wp-content/uploads/2022/10/3d-spatial-audio-icon.svg"
                                                    user={user}
                                                >
                                                    <samp className="user-name">{user.uid}</samp>
                                                </RemoteUser>
                                            </div>
                                        )
                                    ))}
                                </div>
                            </div>
                        </div>
                        {!expertVideoAvailable ? (<div></div>) : (
                            <div className="fixed top-0 bottom-0 right-0 w-1/4 h-full  rounded-lg p-4 overflow-auto">
                                <div className="bg-white flex flex-col items-center space-y-4 p-4">
                                    <div className="bg-white p-8 rounded-lg shadow-md mb-4 w-full max-w-sm text-left">
                                        <h2 className="text-xl font-semibold mb-2">Session Details</h2>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Title:</strong> {session.title}</p>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Description:</strong> {session.description}</p>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Date:</strong> {new Date(session.session_date).toLocaleDateString()}</p>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Time:</strong> {new Date(`1970-01-01T${session.session_time}`).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</p>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Duration:</strong> {session.duration} minutes</p>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Status:</strong> {session.status.charAt(0).toUpperCase() + session.status.slice(1)}</p>
                                        <p className="text-sm text-gray-700 mb-1"><strong>Expert Email:</strong> {session.expert_email}</p>
                                    </div>

                                    <button
                                        id="call-control"
                                        className={`p-2 rounded-lg ${calling ? "bg-red-600 text-white" : "bg-green-600 text-white"}`}
                                        onClick={() => navigate('/live-session')}
                                    >   <span className="ml-2">{"Exit session"}</span>
                                    </button>
                                </div>
                            </div>)

                        }
            </>
                )}
        </div>
        </div >
    );
};
```

The `LiveVideo` component is a React functional component that manages a live video session using Agora's real-time communication SDK. It handles fetching an authorization token, joining a video channel, and managing local and remote user tracks. It also provides UI elements for session details, control over microphone and camera, and displays remote users' video streams. Additionally, it includes error handling, session completion logic, and conditionally renders different views based on session status and user roles.

### LiveSession.jsx:
```
import {useEffect, useState} from "react";
import {useNavigate} from "react-router-dom";
import LiveSessionItemCard from "./LiveSessionItemCard";
import Loader from "./Loader";
import { toast } from "react-toastify";
import { useAuth } from '../AuthContext'; // Adjust import path as necessary

const pageSize = 5;

function LiveSession() {
    const [sessionsList, setSessionsList] = useState([]);
    const [pagination, setPagination] = useState({ page: 1, totalPages: 1 });
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [sessionTime, setSessionTime] = useState('');
    const [sessionLength, setSessionLength] = useState('30');
    const [sessionDate, setSessionDate] = useState('');
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [fetching, setFetching] = useState(false);
    const [submitting, setSubmitting] = useState(false);
    const navigate = useNavigate();
    const { user } = useAuth();

    useEffect(() => {
        fetchSessions(1); // Fetch the first page initially
    }, []);

    const fetchSessions = async (page) => {
        setFetching(true);
        try {
            const response = await fetch(`https://csci-5709-group8.onrender.com/api/sessions/list?page=${page}&pageSize=${pageSize}`);
            const result = await response.json();
            setSessionsList(result.data);
            setPagination(result.pagination);
        } catch (error) {
            console.error('Error fetching sessions:', error);
            toast.error('Error fetching sessions!');
        }
        setFetching(false);
    };

    const handleFormSubmit = async (e) => {
        e.preventDefault();
        const currentDate = new Date();
        const selectedDateTime = new Date(sessionDate);
        selectedDateTime.setHours(Number(sessionTime.split(':')[0]));
        selectedDateTime.setMinutes(Number(sessionTime.split(':')[1]));

        if (selectedDateTime < currentDate) {
            toast.error('Selected date and time cannot be in the past.');
            return;
        }

        const requestPayload = {
            title,
            description,
            session_date: sessionDate,
            session_time: sessionTime,
            duration: sessionLength,
            expert_id: user.id,
            expert_email: user.email, // You might want to use user.email or user.name
            // expert_id: "expert-123", // Replace with actual expert ID
            // expert_email: "nikul@example.com" // Replace with actual expert email
        };

        setSubmitting(true);
        try {
            if (selectedSessionId !== null) {
                // Update session
                const updatePayload = {
                    session_id: selectedSessionId,
                    title,
                    description,
                    session_date: sessionDate,
                    session_time: sessionTime,
                    actual_start_time: new Date().toISOString(),
                    duration: sessionLength,
                    status: "started"
                };
                await fetch('https://csci-5709-group8.onrender.com/api/sessions/edit', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatePayload)
                });
                toast.success('Session updated successfully!');
            } else {
                // Create new session
                await fetch('https://csci-5709-group8.onrender.com/api/sessions/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestPayload)
                });
                toast.success('Session created successfully!');
            }
            // Refresh session list after update or creation
            fetchSessions(pagination.page);
            setTitle('');
            setDescription('');
            setSessionDate('');
            setSessionTime('');
            setSessionLength('30');
        } catch (error) {
            console.error('Error submitting form:', error);
            toast.error('Error submitting form!');
        }
        setSubmitting(false);
    };

    const handleEditSession = (session) => {
        setTitle(session.title);
        setDescription(session.description);
        setSessionDate(new Date(session.session_date).toISOString().split('T')[0]); // Convert date to YYYY-MM-DD
        setSessionTime(session.session_time);
        setSelectedSessionId(session.session_id);
    };

    const handleStartButtonClick = (session) => {
        navigate('/videoCall', {
            state: {
                session,
                loggedInUserId: user.id,
                user_email: user.email
            }
        });
    };

    const handlePageChange = (direction) => {
        const newPage = direction === 'next' ? pagination.page + 1 : pagination.page - 1;
        fetchSessions(newPage);
    };

    return (
        <div
            className="w-full min-h-screen font-poppins antialiased text-gray-900 bg-gradient-to-b from-base-200 to-base-200 p-4 sm:p-8 md:p-12 lg:p-16 xl:p-20">
            <div className="flex justify-between items-center mb-6">
                <div className="font-bold text-black text-xl truncate">Scheduled Session</div>
                <div className="flex items-center">
                    <button
                        className="rounded-box p-4 shadow-lg hover:bg-base-300 hover:text-black transition duration-300"
                        disabled={pagination.page === 1 || fetching}
                        onClick={() => handlePageChange('prev')}
                    >
                        <img src="https://cdn-icons-png.freepik.com/512/318/318477.png" alt="Previous" className="w-6 h-6" />
                    </button>
                    <span>Page {pagination.page} of {pagination.totalPages}</span>
                    <button
                        className="rounded-box p-4 shadow-lg hover:bg-base-300 hover:text-black transition duration-300"
                        disabled={pagination.page === pagination.totalPages || fetching}
                        onClick={() => handlePageChange('next')}
                    >
                        <img src="https://cdn-icons-png.freepik.com/512/318/318476.png" alt="Next" className="w-6 h-6" />
                    </button>
                </div>
            </div>

            {fetching ? (
                <Loader/>
            ) : (
                <>
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                        {sessionsList.map((session) => (
                            <LiveSessionItemCard
                                key={session.session_id}
                                session={session}
                                onEdit={handleEditSession}
                                onStart={handleStartButtonClick}
                                user={user}
                            />
                        ))}
                    </div>

                    <div className="font-bold text-black text-xl mt-8 truncate">Create Session</div>

                    <div className="flex flex-col md:flex-row justify-center mt-8 space-y-8 md:space-y-0 md:space-x-8">
                        <div
                            className="w-full md:w-1/2 p-8 bg-white rounded-xl overflow-hidden shadow-lg order-2 md:order-1">
                            <form className="space-y-4" onSubmit={handleFormSubmit}>
                                <div>
                                    <label htmlFor="title" className="block mb-1">Title:</label>
                                    <input
                                        type="text"
                                        id="title"
                                        name="title"
                                        className="w-full border rounded px-3 py-2"
                                        maxLength="30"
                                        value={title}
                                        onChange={(e) => setTitle(e.target.value)}
                                        required
                                    />
                                </div>
                                <div>
                                    <label htmlFor="description" className="block mb-1">Description:</label>
                                    <textarea
                                        id="description"
                                        name="description"
                                        rows="4"
                                        className="w-full border rounded px-3 py-2"
                                        maxLength="150"
                                        value={description}
                                        onChange={(e) => setDescription(e.target.value)}
                                        required
                                    ></textarea>
                                </div>
                                <div className="flex">
                                    <div className="flex-1 me-2">
                                        <label htmlFor="sessionDate" className="block mb-1">Session Date:</label>
                                        <input
                                            type="date"
                                            id="sessionDate"
                                            name="sessionDate"
                                            className="w-full border rounded px-3 py-2"
                                            value={sessionDate}
                                            onChange={(e) => setSessionDate(e.target.value)}
                                            required
                                        />
                                    </div>
                                    <div className="flex-1">
                                        <label htmlFor="sessionTime" className="block mb-1">Session Time:</label>
                                        <input
                                            type="time"
                                            id="sessionTime"
                                            name="sessionTime"
                                            className="w-full border rounded px-3 py-2"
                                            value={sessionTime}
                                            onChange={(e) => setSessionTime(e.target.value)}
                                            required
                                        />
                                    </div>
                                </div>
                                <div>
                                    <label htmlFor="sessionLength" className="block mb-1">Session Length:</label>
                                    <select
                                        id="sessionLength"
                                        name="sessionLength"
                                        className="w-full border rounded px-3 py-2"
                                        value={sessionLength}
                                        onChange={(e) => setSessionLength(e.target.value)}
                                        required
                                    >
                                        <option value="">Select length</option>
                                        <option value="30">30 minutes</option>
                                        <option value="45">45 minutes</option>
                                        <option value="60">60 minutes</option>
                                    </select>
                                </div>
                                <button
                                    type="submit"
                                    className="bg-black text-white rounded-full py-2 px-4 shadow-md hover:bg-gray-800 transition duration-300 flex items-center justify-center"
                                    disabled={submitting}
                                >
                                    {submitting ? <Loader/> : 'Create Session'}
                                </button>
                            </form>
                        </div>
                        <div
                            className="w-full md:w-1/2 p-8 flex flex-col justify-center items-center order-1 md:order-2">
                            <div className="p-10 bg-opacity-70 bg-backgroundColor rounded-xl">
                                <h2 className="text-s font-extrabold mb-6">Follow These Simple Steps</h2>
                                <ol className="list-decimal pl-4">
                                    <li className="mb-2">Step 1: Fill in the title field (max 30 characters).</li>
                                    <li className="mb-2">Step 2: Fill in the description field (max 150 characters).</li>
                                    <li className="mb-2">Step 3: Select a date from the calendar.</li>
                                    <li className="mb-2">Step 4: Select a time.</li>
                                    <li className="mb-2">Step 5: Choose the duration (30, 45, or 60 minutes).</li>
                                    <li className="mb-2">Step 6: Click Submit.</li>
                                </ol>
                            </div>
                        </div>

                    </div>
                </>
            )}
        </div>
    );
}

export default LiveSession;


```
The LiveSession component in this React file is responsible for displaying and managing live video sessions. It fetches a list of sessions from an API, handles form submission to create or update sessions, and supports pagination for navigating through session pages. The component also includes form validation, session editing, and navigation to a video call page, and features a user-friendly interface for managing session details.


### LiveSessionItemCard.jsx:
```
const LiveSessionItemCard = ({ session, onEdit, onStart, user }) => {
    // Format the session date and time
    const formattedDate = new Date(session.session_date).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
    const formattedTime = new Date(`1970-01-01T${session.session_time}`).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    // Check if the user is the expert for this session
    const isCurrentUserExpert = session.expert_id == user.id;
// console.log("Expert"+session.expert_id);console.log("userId"+user.id);

    return (
        <div className="relative max-w-sm bg-white rounded-xl overflow-hidden shadow-lg">
            {/* Conditionally render the label if the user is the expert */}
            {isCurrentUserExpert && (
                <div className="absolute top-1 right-1 bg-gray-300 text-black text-xs font-semibold py-1 px-3 rounded-xl shadow-md">
                    You
                </div>
            )}
            <div className="p-6 pt-8 flex flex-col h-full">
                <div className="font-bold text-xl mb-2 truncate">{session.title}</div>
                <p className="text-gray-700 text-base line-clamp-2">{session.description}</p>
                <div className="flex-grow"></div>
                <div className="flex items-center mt-2">
                    <div className="text-sm">
                        <p className="mt-1 text-sm text-gray-500">Time: <span className="time">{formattedTime}</span></p>
                        <p className="mt-1 text-sm text-gray-500">Day: <span className="date">{formattedDate}</span></p>
                        <p className="mt-1 text-sm text-gray-500">Duration: <span className="duration">{session.duration}</span></p>
                    </div>
                </div>
                <div className="mt-4 flex justify-between">
                    <button
                        className="bg-base-100 hover:bg-base-200 text-black text-sm flex-1 me-1 py-2 px-4 rounded"
                        onClick={() => onStart(session)}
                    >
                        Start
                    </button>
                    <button
                        className="bg-gray-200 text-black text-sm flex-1 py-2 px-4 rounded hover:bg-gray-300"
                        onClick={() => onEdit(session)}
                    >
                        Edit
                    </button>
                </div>
            </div>
        </div>
    );
};

export default LiveSessionItemCard;


```
The `LiveSessionItemCard` component displays information about a live session in a card format. It shows the session's title, description, date, time, and duration, and includes conditional rendering to label the session if the current user is the expert. It provides buttons to start or edit the session, with appropriate styling and handling functions passed as props.

### PrivateRoute.jsx:

```
import { Navigate } from 'react-router-dom';
import { useAuth } from '../AuthContext'; // Adjust the import according to your auth context location

const PrivateRoute = ({ element: Element }) => {
    const { user } = useAuth(); // Replace with your authentication logic

    return user ? <Element /> : <Navigate to="/signup" />;
};

export default PrivateRoute;


```
The `PrivateRoute` component conditionally renders a component based on user authentication status. If the user is authenticated, it displays the given component; otherwise, it redirects to the `/signup` page.

### UserProfile.jsx:

```
import  { useState, useEffect, useRef } from 'react';
import { NavLink } from 'react-router-dom';
import { useAuth } from '../AuthContext';

const UserProfile = () => {
    const { user, logout } = useAuth();
    const [isPopupVisible, setPopupVisible] = useState(false);
    const popupRef = useRef(null);
    const userEmailRef = useRef(null);

    const handleLogout = () => {
        logout(); // Clear user and token from context
        setPopupVisible(false); // Hide the popup
    };

    // Handle clicks outside the popup
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (
                popupRef.current &&
                !popupRef.current.contains(event.target) &&
                !userEmailRef.current.contains(event.target)
            ) {
                setPopupVisible(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, []);

    return (
        <div>
            {user ? (
                <div className="relative">
                    <div
                        className="hidden md:flex items-center cursor-pointer"
                        ref={userEmailRef}
                        onClick={() => setPopupVisible(!isPopupVisible)}
                    >
                        <span className="text-gray-700 text-lg">{user.email}</span>
                    </div>

                    {isPopupVisible && (
                        <div
                            className="absolute top-full mt-2 right-0 bg-white border border-gray-300 shadow-lg rounded-md p-4"
                            ref={popupRef}
                        >
                            <button
                                onClick={handleLogout}
                                className="bg-zinc-950 hover:bg-base-300 hover:text-black text-white font-bold py-2 px-4 rounded"
                            >
                                Logout
                            </button>
                        </div>
                    )}
                </div>
            ) : (
                <NavLink to="/signup" className='bg-black rounded-box block px-4 py-2 text-white font-bold hover:bg-base-200'>Login</NavLink>
            )}
        </div>
    );
};

export default UserProfile;


```
The `UserProfile` component displays the user's email with an option to log out if the user is authenticated. If logged out, it hides a popup menu; if not logged in, it shows a "Login" button that links to the signup page.


## Note: 
As the netlify is not deploying the node js application properly we used the render site to deploy our backend and netlify for the frontend. Both the backend and frontend has been deployed using the github cicd pipeline. 

## References

[1] "React", React. [Online]. Available at: https://react.dev/ [Accessed: 12 July, 2024].

[2]	"Tailwind CSS", Tailwind Labs Inc. [Online]. Available at: https://tailwindcss.com/  [Accessed: 12 July, 2024].

[3]	"Netlify", Netlify. [Online]. Available at: https://www.netlify.com/  [Accessed: 12 July, 2024].

[4] "React Documentation: Using the State Hook,React [Online]. Available: https://legacy.reactjs.org/docs/hooks-state.html. Accessed: 14 July, 2024.

[5] "Google Fonts," Google[Online]. Available: https://fonts.google.com/. Accessed: 20 July, 2024.

[6] "Agora React SDK," Agora[Online]. Available: https://github.com/AgoraIO/Agora-React-SDK. Accessed: 21 July, 2024. 

[7] "Render - Deploy and Manage Apps," Render[Online]. Available: https://render.com/. Accessed: 21 July, 2024.

## Acknowledgments

* The code provided served as a valuable resource, offering insights into the functionality and logic behind various UI components. I deeply appreciate the dedication and effort put into its development.
* Its contribution has been invaluable, shaping my understanding and approach towards learning specific techniques and approaches. I extend my sincere gratitude for the insights it has provided.